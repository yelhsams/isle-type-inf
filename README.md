# Designing New Type Inference Rules for Cranelift-ISLE Lowering Instructions

By Ashley Sheng (CS340)

[Self Link to GitHub Repository](https://github.com/yelhsams/isle-type-inf)

## Motivation

This project is inspired by this [issue](https://github.com/avanhatt/wasmtime/issues/91), reported by @mmcloughlin. Currently, ISLE implements a [simple unidirectional type-inference algorithm](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/isle/docs/language-reference.md#well-typed-rules-and-type-inference), which typechecks a pattern by propagating expected types provided by the constructor. At this point, the widths of each bitvector may not be known, since types in ISLE are polymorphic. 

> For example, a variable of type Value could be i8, i16, i32, or i64. 

However, bitvector operands must have fixed widths in SMT-LIB, so we must be able to deduce all possible valid widths for argument variables. 

> For example, from the rule **iadd**, we know that the two arguments, x and y, both of type Value must have the same width and fit within 64 bits, so all possible assignments are {(i8, i8), (i16, i16), (i32, i32), (i64, i64)}.

Currently, the type inference system in ISLE relies on a second pass by the SMT solver to resolve these cases, which are referred to as “dynamic widths”.

## Goals

Our main goal is to remove “dynamic widths” from the solver and provide a mapping of possible type environment maps _before_ invoking the solver. I believe this project will provide a valuable opportunity to learn about type inference, apply SMT to a real use-case, and hack in Rust.

I will branch off of Michael’s existing code from issue #91, linked above, but I will work in isolation with the rest of VerISLE. Instead, I will work with directly the ISLE source file as an input, and its possible type mappings as an output.

Foundational Goal:
* Given a `Rule` and its related `Spec`s in the `ISLE::sema`, we wish to 1) reason about the widths of bitvector variables in a pattern and 2) generate SMT constraints matching those observations.


Target Goal:
* We want to enumerate all possible SAT cases generated by the SMT model.
* We will add types defined by `Model` and `Form`.

Stretch Goal:
* Integrate changes with the existing codebase.

## Sources
* [Pardeshi 2023. VeriISLE: Verifying Instruction Selection in Cranelift](http://reports-archive.adm.cs.cmu.edu/anon/2023/CMU-CS-23-126.pdf)



We need to keep track of three types of constraints/nodes:
 concrete (constant), var, bitvectors

 This is because Constraints either assign concrete types to type variables or set them equal to other type variables