# Designing New Type Inference Rules for Cranelift-ISLE Lowering Instructions

By Ashley Sheng (CS340)

[Self Link to GitHub Repository](https://github.com/yelhsams/isle-type-inf)

## Background/Motivating Problem

This project is inspired by this [issue](https://github.com/avanhatt/wasmtime/issues/91), reported by @mmcloughlin. Currently, ISLE implements a [simple unidirectional type-inference algorithm](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/isle/docs/language-reference.md#well-typed-rules-and-type-inference), which typechecks a pattern by propagating expected types provided by the constructor. At this point, the widths of each bitvector may not be known, since types in ISLE are polymorphic. 

> For example, a variable of type Value could be i8, i16, i32, or i64. 

However, bitvector operands must have fixed widths in SMT-LIB, so we must be able to deduce all possible valid widths for argument variables. 

> For example, from the rule **iadd**, we know that the two arguments, x and y, both of type Value must have the same width and fit within 64 bits, so all possible assignments are {(i8, i8), (i16, i16), (i32, i32), (i64, i64)}.

Currently, the type inference system in ISLE relies on a second pass by the SMT solver to resolve these cases, which are referred to as “dynamic widths”.

## Goals

Our main goal is to remove “dynamic widths” from the solver and provide a mapping of possible type environment maps _before_ invoking the solver. I believe this project will provide a valuable opportunity to learn about type inference, apply SMT to a real use-case, and hack in Rust.

I will branch off of Michael’s existing code from issue #91, linked above, but I will work in isolation with the rest of VerISLE. Instead, I will work with directly the ISLE source file as an input, and its possible type mappings as an output.

Foundational Goal:
* Given a `Rule` and its related `Spec`s in the `ISLE::sema`, we wish to 1) reason about the widths of bitvector variables in a pattern and 2) generate SMT constraints matching those observations.


Target Goal:
* We want to enumerate all possible SAT cases generated by the SMT model.
* We will add types defined by `Model` and `Form`.

Stretch Goal:
* Integrate changes with the existing codebase.

## Installation 
* Fork this repository from Github. All dependencies should be installed by Rust at runtime.

## Run (Testable Examples)
There are three testable examples: 
1) `bounded_var.isle` for a simple rule involving `instantiate` and `Value`
> Run this command: `cargo run --bin type-inf -- --aarch64 -t A -i /Users/ashleysheng/cs340/isle-type-inf/test/bound_var.isle`
2) `broken_shift.isle` for a more complex rule involving `ishl`.
> Run this command: `cargo run --bin type-inf -- -t iadd -i /Users/ashleysheng/cs340/isle-type-inf/test/broken_shift.isle` 
3) `broken_uextend.isle` for a rule modeling `uextend`
> Run this command: `cargo run --bin type-inf -- -t uextend -i /Users/ashleysheng/cs340/isle-type-inf/test/broken_uextend.isle`


## Tradeoffs
One major compromise I made for the sake of time, is not removing the `annotation_ir` representations, and not utilizing the existing code in `solver.rs` that extracted dynamic constraints from `veri_ir` to a greater degree. This would also make integrating existing logic from the dynamic widths solver into the new integrated/unified type inference system easier. This would be a future goal.


I had attempted to make a second pass over the annotations and parse the rule in `veri_ir` for additional symbolic constraints, but this would defeat the purpose of the project.

A scope assumption would be that dynamic type inference only currently applies to `BVConcat`. Right now, static inferences are handled by the SMT solver, but not all dynamic cases are solvable currently. For now, I’ve only handled symbolic sums of bitvector widths, but I would like to extend my approach to handle more cases.

Efforts to integrate my changes into the existing codebase have begun: [yelhsams:integrate-type-inf](https://github.com/wellesley-prog-sys/wasmtime/pull/1). While there are incompatibilities and bugs in the `display` functions, the new Type Constraints are propagated to the SMT solver.

## Sources
* [Pardeshi 2023. VeriISLE: Verifying Instruction Selection in Cranelift](http://reports-archive.adm.cs.cmu.edu/anon/2023/CMU-CS-23-126.pdf)
* [Michael's Code](https://github.com/avanhatt/wasmtime/issues/91)
